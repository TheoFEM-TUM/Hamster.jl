"""
    clear_hamster_output(; output_files=["hamster_out.h5", "hamster.out", "Es.dat", "vs.dat"])

Delete output files generated by Hamster.

# Keyword Arguments
- `output_files::Vector{String}`: List of filenames to remove. Defaults to
  `["hamster_out.h5", "hamster.out", "Es.dat", "vs.dat"]`.
"""
function clear_hamster_output(; output_files=["hamster_out.h5", "hamster.out", "ham.h5", "Es.dat", "vs.dat"])
    for file in output_files
        if isfile(file); rm(file, force=true); end
    end
end

"""
    generate_output(conf::Config)

Generates the main output file `hamster.out` with initial run information.

# Arguments
- `conf::Config`: A configuration object containing parameters and settings for the current run.

# Details
This function performs the following tasks:
1. Opens (creates) the file `hamster.out` for writing.
2. Writes the current date and time to the file to record when the Hamster run started.
3. Writes the list of unique hostnames.
"""
function generate_output(conf::Config=get_empty_config(); hostnames=hostnames)
    open("hamster.out", "w") do hamster_out
        print_hamster(hamster_out)

        # Write current date and time of day
        dt = now(); date = Date(dt); time = Time(dt)
        println(hamster_out, "Starting Hamster run on $date at $time.")
        hostlist = string.(unique(hostnames))
        hostlist = replace("$hostlist", "["=>"", "]"=>"")
        println(hamster_out, "  Hamster is running on host(s): $hostlist")
        write_separator(hamster_out)
    end
end

"""
    write_separator(hamster_out)

Write a separator line of `L` times `char`` to the `io_stream`.

# Arguments
- `io_stream::IO`: The io stream to which the separator will be written.
"""
write_separator(io_stream; char='=', L=80) = println(io_stream, char^L)

"""
    append_output_block(block_title, block_tags, block_values; filename="hamster.out")

Append a formatted block of output to the specified file, typically used for logging or report generation.

# Arguments
- `block_title::AbstractString`: The title of the block to be appended. This title will be written as a header.
- `block_tags::AbstractVector{<:AbstractString}`: A vector of tags or labels corresponding to the block's values.
- `block_values::AbstractVector{<:Any}`: A vector of values corresponding to the tags, representing the content to be written.
- `filename::AbstractString`: The name of the file to which the block will be appended. Defaults to `"hamster.out"`.

# Usage
- This function checks if the specified file exists. If it does, it appends a titled block of information with tags and corresponding values.
- Each tag-value pair is written on a new line using the `write_output_line` function.
- A separator line is written after the block for clarity.
"""
function append_output_block(block_title, block_tags, block_values; filename="hamster.out")
    if filename in readdir()
        hamster_out = open("hamster.out", "a")
        println(hamster_out, block_title)
        for (tag, value) in zip(block_tags, block_values)
            write_output_line(hamster_out, tag, value)
        end
        write_separator(hamster_out)
        println(hamster_out, "")
        close(hamster_out)
    end
end

function write_block_summary(block_label, filename="hamster.out"; kwargs...)
    if filename in readdir()
        open(filename, "a") do io
            write(io, "  $block_label Summary\n")
            write_separator(io, char='-')
            for (key, value) in kwargs
                key_string = rpad(replace("      $key:", "["=>"", "]"=>""), 34)
                value_string = rpad(replace("      $value", "["=>"", "]"=>""), 40)
                write(io, "$key_string $value_string\n")
            end
            write_separator(io)
        end
    end
end

"""
    write_output_line(dyntb_out, key, value, L)

Write a line with `key` and `value` pair to the output file `dyntb_out`.
"""
function write_output_line(hamster_out, key, value; L=25)
    key_string = L-length(key) < 0 ? string(key[1:L]) : string(key)
    value_string = L+15-length(value) < 0 ? string(value[1:L]) : string(value)
    Lk = length(key_string); Lv = length(value_string)
    println(hamster_out, "   ", key_string*" "^(L-Lk), " = ", " "^(L+15-Lv)*value_string)
end

"""
    append_output_line(line; filename="hamster.out")

Append a `line` to the output file `hamster.out`.
"""
function append_output_line(line; filename="hamster.out")
    open(filename, "a") do f
        println(f, line)
    end
end

"""
    write_config_tags(filename::String, conf::Config; blocks=nothing, show_desc=false)

Pretty print configuration tags to an output file in a nicely formatted style.

# Arguments
- `filename`: Path to the output file.
- `conf`: Configuration object to read current values.
- `blocks`: Optional list of block names to print. If `nothing`, all blocks are printed.
- `show_desc`: If `true`, adds the description as a comment on each line.
"""
function write_config_tags(conf::Config; blocks=nothing, show_desc=false, filename="hamster.out")
    open(filename, "a") do io
        println(io)
        println(io, "The following input parameters are used:")
        println(io)

        # Organize tags by block
        tags_by_block = Dict{String, Vector{ConfigTag}}()
        for tag in CONFIG_TAGS
            push!(get!(tags_by_block, tag.block, Vector{ConfigTag}()), tag)
        end

        blocks_to_print = blocks === nothing ? sort(collect(keys(tags_by_block))) : blocks

        # Determine column for # comments (fixed for all tags)
        tagval_col_width = maximum(length("    $(tag.name) = $(get_tag(conf, tag))") for tag in CONFIG_TAGS)
        desc_col_start = tagval_col_width + 4  # 4 spaces before #

        for blk in blocks_to_print
            write_separator(io)
            println(io, "  $blk")
            write_separator(io, char='-')

            for tag in tags_by_block[blk]
                val = join(get_tag(conf, tag), " ")
                tagval_str = "    $(tag.name) = $(val)"
                tagval_padded = rpad(tagval_str, desc_col_start)

                if show_desc && !isempty(tag.description)
                    wrap_width = 80 - desc_col_start
                    desc_lines = wrap_text(tag.description, wrap_width)
                    # First line appended to tag=value
                    println(io, tagval_padded, "# ", desc_lines[1])
                    # Remaining lines aligned under the first #
                    for l in desc_lines[2:end]
                        println(io, rpad(" ", desc_col_start), "  ", l)
                    end
                else
                    println(io, tagval_str)
                end
            end

            write_separator(io)
            println(io)
        end
    end
end

# Helper to wrap text into multiple lines
function wrap_text(text::AbstractString, width::Int)
    words = split(text)
    lines = String[]
    line = ""
    for w in words
        if length(line) + (isempty(line) ? 0 : 1) + length(w) > width
            push!(lines, line)
            line = w
        else
            line = isempty(line) ? w : line * " " * w
        end
    end
    if !isempty(line)
        push!(lines, line)
    end
    return lines
end